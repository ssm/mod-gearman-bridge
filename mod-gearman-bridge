#!/usr/bin/env perl

=head1 NAME

mod-gearman-bridge - Read events from one queue, and pass it to
another if it passes a filter.

=head1 AUTHOR

Stig Sandbeck Mathisen <ssm@redpill-linpro.com>

=head1 SYNOPSIS

This program connects to a gearman server, fetches mod-gearman events
from one queue, filters them and passes them on to another queue.

If given keys, it will decrypt messages before filtering, and encrypt
before transmitting.

=head1 LICENCE

mod-gearman-bridge is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

gearman-bridge is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with gearman-bridge. If not, see <http://www.gnu.org/licenses/>.

=cut

use strict;
use warnings;

use Gearman::XS qw(:constants);
use Gearman::XS::Client;
use Gearman::XS::Worker;
use MIME::Base64;
use Crypt::Rijndael;
use Memoize;
use Config::Tiny;

my $AES_KEY_SIZE   = 32;
my $AES_BLOCK_SIZE = 16;

memoize('init_cipher');
memoize('init_parser');
memoize('init_config');

my $config = init_config();

my $worker = init_worker($config);
my $client = init_client($config);

my $parser = init_parser();

### Config: $config

### Queue: $config->{src}->{queue}
$worker->add_function( $config->{src}->{queue}, 0, \&task_router, undef );

### Main loop
while ( 1 ) {
    my $ret = $worker->work();
    if ( $ret != GEARMAN_SUCCESS ) {
        printf( STDERR "%s\n", $worker->error() );
    }
}

## Subroutines

sub task_router {
    my ( $task, $args ) = @_;

    my $parser = init_parser();
    my $config = init_config();

    my $workload = $task->workload();

    if ( $config->{src}->{key} ) {
        ### Decrypting
        $workload = decrypt_task( $config, $workload );
    }

    my $tokens = parse_workload( $parser, $workload );

    if (! $tokens ) {
        ### Unable to parse
        return;
    }

    if ( ! $tokens->{host_name} ) {
        ### Parsed data does not contain host_name
        return;
    }

    ### Parsed data: $tokens

    if ( $config->{filters}->{host_name} ) {
        if ( $tokens->{host_name} =~ $config->{filters}->{host_name} ) {
            ### Matched host_name filter: $config->{filters}->{host_name}
        }
        else {
            ### Did not match host_name filter
            return;
        }
    }

    if ( $config->{dst}->{key} ) {
        ### Encrypting
        $workload = encrypt_task( $config, $workload );
    }

    ### Sending to dst queue: sprintf("%s@%s", $config->{dst}->{queue}, $config->{dst}->{server})
    $client->do_background( $config->{dst}->{queue}, $workload );
}

sub parse_workload() {
    my ( $parser, $workload ) = @_;

    if ( $workload =~ $parser ) {
        my $lines = $/{Line};
        my %tokens = map { $_->{Key} => $_->{Value} } @{$lines};
        return \%tokens;
    }
    else {
        return;
    }
}

sub init_config {
    my $config_file = 'mod-gearman-bridge.conf';
    my $config      = Config::Tiny->read($config_file)
        or die( Config::Tiny->errstr );

    return $config;
}

sub init_parser {
    use Regexp::Grammars;
    my $parser = qr{
        <[Line]>+

        <token: Key>   <MATCH= (\w+) >
        <token: Value> <MATCH= (.*) >

        <rule: Line>   <Key> = <Value>
    }x;
}

sub init_worker {
    my ($config) = @_;
    my $worker   = Gearman::XS::Worker->new();
    my $server   = $config->{src}->{server};
    ### [worker] adding server: $server
    my $ret = $worker->add_servers($server);
    if ( $ret != GEARMAN_SUCCESS ) {
        printf( STDERR "%s\n", $worker->error() );
        exit(1);
    }
    return $worker;
}

sub init_client {
    my ($config) = @_;
    my $client   = Gearman::XS::Client->new;
    my $server   = $config->{dst}->{server};
    ### [client] adding server: $server
    my $ret = $client->add_servers($server);
    if ( $ret != GEARMAN_SUCCESS ) {
        printf( STDERR "%s\n", $client->error() );
        exit(1);
    }
    return $client;
}

sub init_cipher {
    my ($tmp_key) = @_;

    my $key = pad_key($tmp_key);
    my $cipher = Crypt::Rijndael->new( $key, Crypt::Rijndael::MODE_ECB() );
    return $cipher;
}

sub decrypt_task {
    my ( $config, $task ) = @_;
    my $cipher = init_cipher( $config->{src}->{key} );

    my $encrypted = decode_base64($task);

    my $plaintext_padded = $cipher->decrypt($encrypted);

    my $plaintext = unpad_plaintext($plaintext_padded);

    return $plaintext;
}

sub encrypt_task {
    my ( $config, $plaintext ) = @_;
    my $cipher = init_cipher( $config->{dst}->{key} );

    $plaintext = pad_plaintext($plaintext);
    my $encrypted      = $cipher->encrypt($plaintext);
    my $base64_encoded = encode_base64($encrypted);
    return $base64_encoded;
}

sub pad_plaintext {
    my $plaintext = shift;

    if ( length($plaintext) % $AES_BLOCK_SIZE != 0 ) {
        $plaintext .= "\0"
            x ( $AES_BLOCK_SIZE - ( length($plaintext) % $AES_BLOCK_SIZE ) );
    }

    return $plaintext;
}

sub pad_key {
    my ($key) = @_;
    ### Key candidate: $key
    if ( length($key) < $AES_KEY_SIZE ) {
        $key .= "\0" x ( $AES_KEY_SIZE - ( length($key) ) );
    }
    elsif ( length($key) > $AES_KEY_SIZE ) {
        $key = sprintf( '%.32s', $key );
    }
    ### Key: $key
    return $key;
}

sub unpad_plaintext {
    my $plaintext = shift;

    $plaintext =~ s{ \0+$ }{ }x;

    return $plaintext;
}
