#!/usr/bin/env perl

=head1 NAME

gearman-bridge - Copy tasks from one queue to multiple others

=head1 AUTHOR

Stig Sandbeck Mathisen <ssm@redpill-linpro.com>

=head1 SYNOPSIS

This program listens on one queue, and copies all tasks to several
other queues.

This is used to accept passive icinga check results on one queue, and
send them to multiple icinga instances, each listening on several
queues.

=head1 LICENCE

gearman-bridge is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

gearman-bridge is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with gearman-bridge.  If not, see <http://www.gnu.org/licenses/>.

=cut

use strict;
use warnings;

use Gearman::XS qw(:constants);
use Gearman::XS::Client;
use Gearman::XS::Worker;
use MIME::Base64;
use Crypt::Rijndael;
use Memoize;

my $AES_KEY_SIZE   = 32;
my $AES_BLOCK_SIZE = 16;

memoize('init_cipher');

my $config = {
    src => {
        job_servers => 'monitor.i.bitbit.net:4731',
        queues =>
            [ 'check_results_monitor2-osl2', 'check_results_monitor5-osl2' ]
    },
    dst => {
        job_servers => 'monitor.i.bitbit.net:4732',
        queues      => ['check_results'],
        }

};

my $worker = init_worker($config);
my $client = init_client($config);

foreach my $queue ( @{ $config->{src}->{queues} } ) {
    ### Adding function: $queue
    $worker->add_function( $queue, 0, \&task_router, $config );
}

### Main loop
while (1) {
    $worker->work();
}

## Subroutines

sub task_router {
    my ($task) = @_;

    my $workload = decrypt_task( $config, $task->workload() );

    ### Task: $workload

    if ($config->{dst}->{key}) {
        ### Key is set for destination, encrypting
        $workload = encrypt_task( $config, $workload );
    }

    send_to_dst_queue( $config, $workload );
}

sub init_worker {
    my ($config) = @_;
    my $worker = Gearman::XS::Worker->new();
    my $servers = join( ',', $config->{src}->{job_servers} );
    ### [worker] adding servers: $servers
    my $ret = $worker->add_servers($servers);
    if ( $ret != GEARMAN_SUCCESS ) {
        printf( STDERR "%s\n", $worker->error() );
        exit(1);
    }
    return $worker;
}

sub init_client {
    my ($config) = @_;
    my $client = Gearman::XS::Client->new;
    my $servers = join( ',', $config->{dst}->{job_servers} );
    ### [client] adding servers: $servers
    my $ret = $client->add_servers($servers);
    if ( $ret != GEARMAN_SUCCESS ) {
        printf( STDERR "%s\n", $client->error() );
        exit(1);
    }
    return $client;
}

sub send_to_dst_queue {
    my ($config, $workload) = @_;
    ### dst data: $workload
    foreach my $dst_queue ( @{ $config->{dst}->{queues} } ) {
        ### dst queue: $dst_queue
        $client->do_background( $dst_queue, $workload );
    }
}

sub init_cipher {
    my ($tmp_key) = @_;

    my $key = pad_key($tmp_key);
    my $cipher = Crypt::Rijndael->new( $key, Crypt::Rijndael::MODE_ECB() );
    return $cipher;
}

sub decrypt_task {
    my ( $config, $task ) = @_;
    my $cipher = init_cipher( $config->{src}->{key} );

    ### [decrypt_task] task: $task

    my $encrypted = decode_base64( $task );

    my $plaintext_padded = $cipher->decrypt($encrypted);

    my $plaintext = unpad_plaintext($plaintext_padded);

    ### [decrypt_task] plain: $plaintext

    return $plaintext;
}

sub encrypt_task {
    my ( $config, $plaintext ) = @_;
    my $cipher = init_cipher( $config->{dst}->{key} );

    $plaintext = pad_plaintext($plaintext);
    my $encrypted      = $cipher->encrypt($plaintext);
    my $base64_encoded = encode_base64($encrypted);
    return $base64_encoded;
}

sub pad_plaintext {
    my $plaintext = shift;

    if ( length($plaintext) % $AES_BLOCK_SIZE != 0 ) {
        $plaintext .= "\0"
            x ( $AES_BLOCK_SIZE - ( length($plaintext) % $AES_BLOCK_SIZE ) );
    }

    return $plaintext;
}

sub pad_key {
    my ($key) = @_;
    ### Key candidate: $key
    if ( length($key) < $AES_KEY_SIZE ) {
        $key .= "\0" x ( $AES_KEY_SIZE - ( length($key) ) );
    }
    elsif ( length($key) > $AES_KEY_SIZE ) {
        $key = sprintf( '%.32s', $key );
    }
    ### Key: $key
    return $key;
}

sub unpad_plaintext {
    my $plaintext = shift;

    $plaintext =~ s{ \0+$ }{ }x;

    return $plaintext;
}
